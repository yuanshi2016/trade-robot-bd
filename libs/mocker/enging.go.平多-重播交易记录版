package mocker

import (
	"fmt"
	"github.com/360EntSecGroup-Skylar/excelize/v2"
	"github.com/xjieinfo/xjgo/xjcore/xjexcel"
	"log"
	"runtime"
	"sync"
	"time"
	"trade-robot-bd/app/grid-strategy-svc/util/utils"
	"trade-robot-bd/libs/goex"
	"trade-robot-bd/libs/goex/binance"
	"trade-robot-bd/libs/helper"
)

func (m *MockCyCle) RunCycleWhere() (r []*WhereCycleOne) {
	var mc = WhereCycleOne{
		Comm: Comm{Symbol: m.Symbol},
		MockDetail: goex.MockDetail{
			OldUsd:  300,
			Usd:     300,
			Balance: 0,
			Type:    goex.NewOrder_UM,
			CpUsd:   10,
			FeeRate: 0.04,
		},
	}
	if len(m.RsiMin) < 1 {
		m.RsiMin = []float64{0}
	}
	if len(m.RsiMax) < 1 {
		m.RsiMax = []float64{0}
	}
	if len(m.RsiLength) < 1 {
		m.RsiLength = []int{0}
	}
	if len(m.MfiMin) < 1 {
		m.MfiMin = []float64{0}
	}
	if len(m.MfiMax) < 1 {
		m.MfiMax = []float64{0}
	}
	if len(m.MfiLength) < 1 {
		m.MfiLength = []int{0}
	}
	if len(m.RviMin) < 1 {
		m.RviMin = []float64{0}
	}
	if len(m.RviMax) < 1 {
		m.RviMax = []float64{0}
	}
	if len(m.RviLength) < 1 {
		m.RviLength = []int{0}
	}
	if len(m.StopLossRate) < 1 {
		m.StopLossRate = []float64{0}
	}
	if len(m.AtrLength) < 1 {
		m.AtrLength = []int{0}
	}
	if len(m.ProfitType) < 1 {
		m.ProfitType = []CloseSignal{ProfitRate, ProfitSignal}
	}
	if len(m.Lever) < 1 {
		m.Lever = []int{5} //默认5倍合约
	}

	for rviMinI, _ := range m.RviMin {
		for rviMaxI, _ := range m.RviMax {
			for rviLengthI, _ := range m.RviLength {
				for mfiMinI, _ := range m.MfiMin {
					for mfiLengthI, _ := range m.MfiLength {
						for rsiMinI, _ := range m.RsiMin {
							for rsiLengthI, _ := range m.RsiLength {
								for IrsiMax, _ := range m.RsiMax {
									for rateI, _ := range m.ProfitRate {
										for StopLossI, _ := range m.StopLossRate {
											for AtrLengthI, _ := range m.AtrLength {
												for ProfitTypeI, _ := range m.ProfitType {
													for LeverI, _ := range m.Lever {
														icopy := mc
														icopy.RviMin = m.RviMin[rviMinI]
														icopy.RviMax = m.RviMax[rviMaxI]
														icopy.RviLength = m.RviLength[rviLengthI]
														icopy.MfiMin = m.MfiMin[mfiMinI]
														icopy.MfiLength = m.MfiLength[mfiLengthI]
														icopy.RsiMin = m.RsiMin[rsiMinI]
														icopy.RsiLength = m.RsiLength[rsiLengthI]
														icopy.RsiMax = m.RsiMax[IrsiMax]
														icopy.ProfitRate = m.ProfitRate[rateI]
														icopy.StopLossRate = m.StopLossRate[StopLossI]
														icopy.AtrLength = m.AtrLength[AtrLengthI]
														icopy.ProfitType = m.ProfitType[ProfitTypeI]
														icopy.MockDetail.Lever = int64(m.Lever[LeverI])
														r = append(r, &icopy)
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return r
}

func (m *MockCyCle) MakeCycleWhere(bn *binance.Binance, actionType int) {
	var list goex.MockResults
	log.Printf("数据回测 - 数据整理中....")
	if actionType == WhereAll {
		list = m.MakeCycleWhereAll(bn)
	} else {
		list = m.MakeCycleWhereSplit(bn)
	}
	var f *excelize.File
	log.Printf("[%vm]回测完毕,数据: %v 组\n", m.Cycle, len(list))
	pl := list.SplitToFlotList("desc", true)
	for i := 0; i < len(pl); i++ {
		itemMock := pl[i]
		//if itemMock.IsLiquidation {
		//	continue
		//}
		itemMock.ExportOrders(m.Cycle, m.StartDay, m.EndDay)
		log.Printf("%v分钟[%s-%s]回测数据: 初始余额:%v 当前余额:%v 交易次数:%v Atr:%v 平仓条件:%v 收益率:%v 止损率:%v %%  爆仓:%v \n",
			m.Cycle, m.StartDay, m.EndDay, itemMock.OldUsd, itemMock.Usd, itemMock.TradeNum,
			itemMock.AtrLength,
			itemMock.ProfitType,
			itemMock.ProfitRate,
			itemMock.StopLossRate,
			helper.IfThen(itemMock.IsLiquidation, "是", "否"))
		break
	}

	f = xjexcel.ListToExcel(list, "", fmt.Sprintf("%vm回测数据", m.Cycle))
	helper.Exists("mocktest", true, true)
	err := f.SaveAs(fmt.Sprintf("mocktest/%vm回测数据.xlsx", m.Cycle))
	if err != nil {
		log.Fatal("保存失败")
		return
	}
}
func (m *MockCyCle) MakeCycleWhereAll(bn *binance.Binance) (list goex.MockResults) {
	m.Brackets = LoadBrackets(bn) //加载杠杆信息
	whereOne := m.RunCycleWhere()
	log.Printf("条件重组完成:共%v组数据", len(whereOne))

	kline := binance.GetKLines("FUTURES_UM", "klines", "daily", m.StartDay, m.EndDay,
		[]string{fmt.Sprintf("%vm", m.Cycle)}, []string{m.Symbol.ToSymbol("")}, m.Symbol)
	log.Printf("K线数据读取完毕,共%v条 等待排序...", len(kline))
	m.kLineData = goex.KlineSort(kline, "asc")
	log.Println("K线数据排序完成")
	trades := binance.GetTrade("FUTURES_UM", "trades", "daily", m.StartDay, m.EndDay, []string{}, []string{m.Symbol.ToSymbol("")}, m.Symbol)
	log.Printf("交易数据读取完毕,共%v条 等待排序...", len(trades))
	m.TradeData = goex.BubbleSortGeneric1(trades, runtime.NumCPU())
	log.Printf("数据加载完毕，等待整合,[K线:%v-交易记录:%v]\n", len(m.kLineData), len(m.TradeData))

	m.KlineLinkTrade() //关联K线与交易记录
	log.Printf("[%v-%v]日数据关联完成[%v]", m.StartDay, m.EndDay, len(m.KlinsLikeTrade))
	var wg = new(sync.WaitGroup)
	//pool := tunny.NewFunc(10000000, func(i interface{}) interface{} {
	//	_one := whereOne[i.(int)]
	//	var r = _one.RsiOrder(m)
	//	list = append(list, *r)
	//	log.Printf("正在执行第%v个任务 \n", i.(int))
	//	wg.Done()
	//	return nil
	//})
	//defer func() {
	//	pool.Close()
	//	m.kLineData = nil
	//	m.TradeData = nil
	//	m.KlinsLikeTrade = nil
	//}()
	for iR := 0; iR < len(whereOne); iR++ {
		wg.Add(1)
		iR := iR
		go func() {
			var r = whereOne[iR].RsiOrder(m)
			list = append(list, *r)
			wg.Done()
		}()
		//go pool.Process(iR)
	}
	log.Println("任务分发完成，正在执行...")
	wg.Wait()
	log.Println("任务执行完成，正在将结果写入文件...")
	return list
}

// MakeCycleWhereSplit 分割回测 防止数据过大 造成溢出
func (m *MockCyCle) MakeCycleWhereSplit(bn *binance.Binance) (list goex.MockResults) {
	// 将K线数据 按天分割后 逐一回测
	var klinData = binance.DownloadData("FUTURES_UM", "klines", "daily", m.StartDay, m.EndDay, []string{fmt.Sprintf("%vm", m.Cycle)}, []string{m.Symbol.ToSymbol("")})
	var tradeData = binance.DownloadData("FUTURES_UM", "trades", "daily", m.StartDay, m.EndDay, []string{}, []string{m.Symbol.ToSymbol("")})
	log.Printf("数据加载完毕，等待整合,[%v-%v]\n", len(klinData), len(tradeData))
	m.Brackets = LoadBrackets(bn) //加载杠杆信息

	whereOne := m.RunCycleWhere()
	log.Printf("条件重组完成:共%v组数据", len(whereOne))
	var wg = new(sync.WaitGroup)
	for i := 0; i < len(klinData); i++ {
		m.kLineData = []*goex.Kline{}
		m.TradeData = []*goex.Trade{}
		// 按天分割后的K线数据与交易记录
		m.kLineData = goex.LocalKlineCsv(klinData[i], m.Symbol)
		m.TradeData = goex.LocalTradeCsv(tradeData[i], m.Symbol)
		m.KlineLinkTrade() //关联K线与交易记录
		log.Printf("[%v]日数据关联完成[%v]", time.UnixMilli(m.kLineData[0].CloseTime).Format(helper.TimeFormatYmdHis), len(m.KlinsLikeTrade))
		for iR := 0; iR < len(whereOne); iR++ {
			_iR := iR
			go func() {
				wg.Add(1)
				_one := whereOne[_iR]
				var r = _one.RsiOrder(m)
				wg.Done()
				if i >= len(klinData)-1 {
					list = append(list, *r)
				}
			}()
		}
		wg.Wait()
		log.Printf("处理完毕")
	}
	return list
}

// RsiOrder Rsi量化大法
func (m *WhereCycleOne) RsiOrder(mockData *MockCyCle) (r *goex.MockResult) {
	_mockResult := &goex.MockResult{
		AtrLength:    m.AtrLength,
		ProfitRate:   m.ProfitRate,
		OldUsd:       m.MockDetail.OldUsd,
		StopLossRate: m.StopLossRate,
		ProfitType:   m.ProfitType.String(),
	}
	//创建订单
	newOrder := func(direction, closeTime int64) *goex.MockOrder {
		return &goex.MockOrder{
			Direction: direction,
			Type:      m.MockDetail.Type,
			Lever:     m.MockDetail.Lever,
			Quantity:  helper.IfThen(m.MockDetail.Type == goex.NewOrder_UM, m.MockDetail.Usd*float64(m.MockDetail.Lever), m.MockDetail.Usd),
			FeeRate:   m.MockDetail.FeeRate,
			CpUsd:     m.MockDetail.CpUsd,
			BidTime:   closeTime,
		}
	}
	openBuy := func(actionPrice float64, closeTime int64) bool {
		if m.Signal == goex.OPEN_BUY && m.MockDetail.BuyOrder == nil { //达到买多条件 - 判断有无货币购买(包含资金切割) 注意:非本地回测下，数据具有实时性
			m.MockDetail.Mutex.Lock()
			var order = newOrder(goex.NewOrder_Buy, closeTime)                                //生成做多订单
			order.Buy(actionPrice)                                                            //非本地数据回测下 数据具有实时性 本地模拟 暂时取最低价与收盘价折中值
			order.CalcLiquidation(m.MockDetail.Usd, mockData.Brackets[m.Symbol.ToSymbol("")]) //计算爆仓价 传参格式 余额 保证金维持比例
			m.MockDetail.BuyOrder = order
			m.MockDetail.TradeNum++
			//因为本地数据回测  是根据K线收盘价操作  所以下买单后  需要在下一个K线判断是否卖出/平多
			m.MockDetail.Mutex.Unlock()
			return true
		}
		return false
	}

	// 打开空单
	openSell := func(actionPrice float64, closeTime int64) bool {
		//检测当前是否有空单进行做空
		if m.MockDetail.SellOrder == nil && m.Signal == goex.OPEN_SELL {
			m.MockDetail.Mutex.Lock()
			var order = newOrder(goex.NewOrder_Sell, closeTime)                               //生成做空订单
			order.Buy(actionPrice)                                                            //非本地数据回测下 数据具有实时性 本地模拟 暂时取最高与开盘折中值
			order.CalcLiquidation(m.MockDetail.Usd, mockData.Brackets[m.Symbol.ToSymbol("")]) //计算爆仓价 传参格式 余额 保证金维持比例
			m.MockDetail.SellOrder = order
			m.MockDetail.TradeNum++
			m.MockDetail.Mutex.Unlock()
			return true
		}
		return false
	}
	if m.Signal == goex.OPEN_SELL {
		log.Println("卖出信号")
	}
	// 关闭空单
	closeSell := func(actionPrice float64, closeTime int64) {
		order := m.MockDetail.SellOrder
		if order == nil || m.Signal != goex.OPEN_BUY {
			return
		}
		spot := &goex.MockOrder{
			Direction: order.Direction,
			Type:      order.Type,
			Lever:     order.Lever,
			Quantity:  order.Quantity,
			FeeRate:   order.FeeRate,
			CpUsd:     order.CpUsd,
		}
		spot.Buy(order.Open)
		spot.Sell(actionPrice)
		spot.CalcCpUp()
		action := func() {
			m.MockDetail.SellOrder.Sell(actionPrice) //非本地数据回测下 数据具有实时性 本地模拟 暂时取最低价与收盘价折中值
			m.MockDetail.SellOrder.AskTime = closeTime
			m.MockDetail.SellOrder.CalcCpUp()
			m.MockDetail.Usd += m.MockDetail.SellOrder.NetGainUSd
			m.MockDetail.SellOrder.Usd = m.MockDetail.Usd //快照 模拟余额
			m.MockDetail.HistoryOrder = append(m.MockDetail.HistoryOrder, m.MockDetail.SellOrder)
			m.MockDetail.SellOrder = nil
		}
		//触发止损
		if spot.NetRate <= m.StopLossRate || (spot.NetRate >= m.ProfitRate && m.ProfitType == ProfitRate) {
			action()
			return
		}
		if m.Signal == goex.OPEN_BUY && m.ProfitType == ProfitSignal {
			if spot.NetRate > m.StopLossRate && spot.NetRate < 0 { //出现亏损 但未达到止损
				return
			}
			action()
			return
		}
	}
	closeBuy := func(closeTime int64) *goex.MockResult {
		if m.MockDetail.BuyOrder != nil {
			//如果持有订单的情况下 需要取出当前K线中的所有交易 逐一进行比对 达到收益率后 进行平仓/卖出操作
			var trade = mockData.KlinsLikeTrade[closeTime]
			action := func(price float64, date int64) {
				m.MockDetail.BuyOrder.Sell(price)
				m.MockDetail.BuyOrder.AskTime = date
				m.MockDetail.BuyOrder.CalcCpUp()
				m.MockDetail.Usd += m.MockDetail.BuyOrder.NetGainUSd
				m.MockDetail.BuyOrder.Usd = m.MockDetail.Usd //快照 模拟余额
				m.MockDetail.HistoryOrder = append(m.MockDetail.HistoryOrder, m.MockDetail.BuyOrder)
				m.MockDetail.BuyOrder = nil
			}
			for ir := 0; ir < len(trade); ir++ {
				var itemTrade = trade[ir]
				order := m.MockDetail.BuyOrder
				if helper.IfThen(order.Type == goex.NewOrder_Buy, itemTrade.Price <= order.Liquidation, itemTrade.Price >= order.Liquidation) { //爆仓啦
					_mockResult.IsLiquidation = true
					m.IsLiquidation = true
					_mockResult.Usd = m.MockDetail.Usd
					_mockResult.TradeNum = m.MockDetail.TradeNum
					m.MockDetail.BuyOrder.Sell(itemTrade.Price)
					m.MockDetail.BuyOrder.AskTime = itemTrade.Date
					m.MockDetail.BuyOrder.CalcCpUp()
					m.MockDetail.HistoryOrder = append(m.MockDetail.HistoryOrder, m.MockDetail.BuyOrder)
					_mockResult.Order = m.MockDetail.HistoryOrder
					return _mockResult
				}
				spot := &goex.MockOrder{
					Direction: order.Direction,
					Type:      order.Type,
					Lever:     order.Lever,
					Quantity:  order.Quantity,
					FeeRate:   order.FeeRate,
					CpUsd:     order.CpUsd,
				}
				spot.Buy(order.Open)
				spot.Sell(itemTrade.Price)
				spot.CalcCpUp()
				//触发止损
				if spot.NetRate <= m.StopLossRate || (spot.NetRate >= m.ProfitRate && m.ProfitType == ProfitRate) {
					action(itemTrade.Price, itemTrade.Date)
					break
				}
				if m.Signal == goex.OPEN_SELL && m.ProfitType == ProfitSignal {
					if spot.NetRate > m.StopLossRate && spot.NetRate < 0 { //出现亏损 但未达到止损
						break
					}
					action(itemTrade.Price, itemTrade.Date)
					break
				}
			}
		}
		return nil
	}
	// 测试数据爆仓后 不再进行操作
	if m.IsLiquidation {
		return
	}
	for i := 0; i < len(mockData.kLineData); i++ {
		if i >= len(mockData.kLineData)-2 {
			_mockResult.Usd = m.MockDetail.Usd
			_mockResult.TradeNum = m.MockDetail.TradeNum
			_mockResult.Order = m.MockDetail.HistoryOrder
		}
		var item = mockData.kLineData[i]
		m.CalcKline(item, 0)
		m.GetSignal()
		_, _ = openSell, closeSell
		_, _ = openBuy, closeBuy
		if m.Signal == goex.OPEN_SELL {
			log.Println("做空信号", item.Close, time.UnixMilli(item.CloseTime).Format(helper.TimeFormatYmdHi))
		}
		if ok := openSell((item.High+item.Open)/2, item.CloseTime); ok {
			continue
		}
		closeSell((item.Close+item.Low)/2, item.CloseTime) //查看是否有做空订单进行平空
		// 下多单后跳出
		//if ok := openBuy((item.Close+item.Low)/2, item.CloseTime); ok {
		//	continue
		//}
		////如果结果不为nil  则返回爆仓数据 该条测试组意味着暂停
		//if r := closeBuy(item.CloseTime); r != nil {
		//	return r
		//}
	}

	return _mockResult
}

// LoadBrackets 加载币种杠杆与保证金信息
func LoadBrackets(bn *binance.Binance) Brackets {
	brk := make(Brackets)
	lp := bn.Brackets()
	for i := range lp {
		item := lp[i]
		brk[item.Symbol] = &item
	}
	log.Printf("杠杆与保证金列表加载完毕:%v", len(brk))
	return brk
}

// CalcTrade 通过传入交易记录 进行后置处理
func CalcTrade(trade *goex.Trade) {

}

// CalcKline 通过K线 进行数据后置处理
func (m *WhereCycleOne) CalcKline(kline *goex.Kline, i int) {
	if len(m.kLineData) <= 0 {
		m.kLineData = append(m.kLineData, kline)
	} else if kline.Timestamp == m.kLineData[len(m.kLineData)-1].Timestamp {
		m.kLineData[len(m.kLineData)-1] = kline
	} else {
		m.kLineData = append(m.kLineData, kline)
	}
	if len(m.kLineData) > 167 {
		m.kLineData = m.kLineData[1:]
	}
}
func (m *WhereCycleOne) GetSignal() int {
	m.Signal = m.SignalRenko()
	return m.Signal
}

// SignalRenko Renko信号
func (m *WhereCycleOne) SignalRenko() int {
	if len(m.kLineData) < m.AtrLength+1 {
		return -1
	}
	Renko := goex.KlineToRenKo(m.kLineData, m.AtrLength, goex.InClose)
	openRenko := utils.SplitToFlotList(goex.RealData(Renko, goex.InOpen), "Reverse")
	closeRenko := utils.SplitToFlotList(goex.RealData(Renko, goex.InClose), "Reverse")
	buySignal := goex.Crossunder(openRenko, closeRenko)
	sellSignal := goex.Crossover(openRenko, closeRenko)
	if buySignal {
		return goex.OPEN_BUY
	}
	if sellSignal {
		return goex.OPEN_SELL
	}
	return -1 // -1为未识别信号
}

// SignalMfi Mfi信号
func (m *WhereCycleOne) SignalMfi() int {
	if len(m.kLineData) < m.MfiLength+1 {
		return -1
	}
	mfi := goex.CalcMfi(m.kLineData, m.MfiLength)
	if len(mfi) == 0 {
		return -1
	}
	m.LastMfi = mfi[len(mfi)-1]
	if m.LastMfi <= m.MfiMin && m.MfiMin != 0 {
		return goex.OPEN_BUY //买入 / 平空信号
	}
	if m.LastMfi >= m.MfiMax && m.MfiMax != 0 {
		return goex.OPEN_SELL //卖出 / 平多信号
	}
	return -1 // -1为未识别信号
}

// SignalRsi Rsi信号
func (m *WhereCycleOne) SignalRsi() int {
	if len(m.kLineData) < m.RsiLength+1 {
		return -1
	}
	rsi := goex.CalcRsi(m.kLineData, m.RsiLength)
	if len(rsi) == 0 {
		return -1
	}
	m.LastRsi = rsi[len(rsi)-1]
	if m.LastRsi <= m.RsiMin && m.RsiMin != 0 {
		return goex.OPEN_BUY //买入 / 平空信号
	}
	if m.LastRsi >= m.RsiMax && m.RsiMax != 0 {
		return goex.OPEN_SELL //卖出 / 平多信号
	}
	return -1 // -1为未识别信号
}

// SignalRvi Rvi信号
func (m *WhereCycleOne) SignalRvi() int {
	if len(m.kLineData) < m.RviLength+1 {
		return -1
	}
	rvi := goex.CalcRvgi(m.kLineData, m.RviLength)
	if len(rvi) == 0 {
		return -1
	}
	m.LastRvi = rvi[len(rvi)-1]
	if m.LastRvi <= m.RviMin {
		return goex.OPEN_BUY //买入 / 平空信号
	}
	if m.LastRvi >= m.RviMax && m.RviMax != 0 {
		return goex.OPEN_SELL //卖出 / 平多信号
	}
	return -1 // -1为未识别信号
}

// SubTrade 订阅交易记录
func (m *WhereCycleOne) SubTrade(bn *binance.BinanceWs) {
	err := bn.SubscribeAggTrade(m.Symbol, func(trade *goex.Trade) {
		CalcTrade(trade)
	})
	if err != nil {
		fmt.Println("运行失败", err)
	}
}

// SubKline 读取并订阅K线
func (m *WhereCycleOne) SubKline(bn *binance.BinanceWs, bnt *binance.BinanceSwap) {
	var err error
	m.kLineData, err = bnt.GetKlineRecords(m.Symbol, goex.KLINE_PERIOD_5MIN, 167, 0)
	if err != nil {
		log.Fatalf("运行失败,获取K线报错-%v", err.Error())
	}
	m.RsiArr = goex.CalcRsi(m.kLineData, m.RsiLength)
	m.MfiArr = goex.CalcMfi(m.kLineData, m.MfiLength)
	bn.KlineCallback = m.CalcKline
	err = bn.SubscribeKline(m.Symbol, goex.KLINE_PERIOD_5MIN)
	if err != nil {
		fmt.Println("运行失败", err)
	}
}

// 读取在线K线数据
func onLineKline(bn *binance.BinanceWs, bnt *binance.BinanceSwap) {
	mc := WhereCycleOne{
		Comm:      Comm{Symbol: goex.BNB_USDT},
		RsiLength: 14,
		MfiLength: 6,
	}
	mc.SubKline(bn, bnt)
}
