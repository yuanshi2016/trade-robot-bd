package mocker

import (
	"fmt"
	"github.com/360EntSecGroup-Skylar/excelize/v2"
	"github.com/Jeffail/tunny"
	"github.com/xjieinfo/xjgo/xjcore/xjexcel"
	"log"
	"runtime"
	"sync"
	"time"
	"trade-robot-bd/libs/goex"
	"trade-robot-bd/libs/goex/binance"
	"trade-robot-bd/libs/helper"
)

func (m *MockCyCle) RunCycleWhere() (r []*WhereCycleOne) {

	var mc = WhereCycleOne{
		Comm: Comm{Symbol: m.Symbol},
		MockDetail: goex.MockDetail{
			OldUsd:    300,
			Usd:       300,
			Balance:   0,
			Direction: goex.NewOrder_Buy,
			Type:      goex.NewOrder_UM,
			Lever:     5,
			CpUsd:     10,
			FeeRate:   0.04,
		},
	}
	if len(m.RsiMin) < 1 {
		m.RsiMin = []float64{0}
	}
	if len(m.RviMax) < 1 {
		m.RviMax = []float64{0}
	}
	if len(m.RsiLength) < 1 {
		m.RsiLength = []int{0}
	}
	if len(m.MfiMin) < 1 {
		m.MfiMin = []float64{0}
	}
	if len(m.MfiMax) < 1 {
		m.MfiMax = []float64{0}
	}
	if len(m.MfiLength) < 1 {
		m.MfiLength = []int{0}
	}
	if len(m.RviMin) < 1 {
		m.RviMin = []float64{0}
	}
	if len(m.RviMax) < 1 {
		m.RviMax = []float64{0}
	}
	if len(m.RviLength) < 1 {
		m.RviLength = []int{0}
	}
	if len(m.StopLossRate) < 1 {
		m.StopLossRate = []float64{0}
	}
	for rviMinI, _ := range m.RviMin {
		for rviMaxI, _ := range m.RviMax {
			for rviLengthI, _ := range m.RviLength {
				for mfiMinI, _ := range m.MfiMin {
					for mfiLengthI, _ := range m.MfiLength {
						for rsiMinI, _ := range m.RsiMin {
							for rsiLengthI, _ := range m.RsiLength {
								for IrsiMax, _ := range m.RsiMax {
									for rateI, _ := range m.ProfitRate {
										for StopLossI, _ := range m.StopLossRate {
											icopy := mc
											icopy.RviMin = m.RviMin[rviMinI]
											icopy.RviMax = m.RviMax[rviMaxI]
											icopy.RviLength = m.RviLength[rviLengthI]
											icopy.MfiMin = m.MfiMin[mfiMinI]
											icopy.MfiLength = m.MfiLength[mfiLengthI]
											icopy.RsiMin = m.RsiMin[rsiMinI]
											icopy.RsiLength = m.RsiLength[rsiLengthI]
											icopy.RsiMax = m.RsiMax[IrsiMax]
											icopy.ProfitRate = m.ProfitRate[rateI]
											icopy.StopLossRate = m.StopLossRate[StopLossI]
											r = append(r, &icopy)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return r
}

func (m *MockCyCle) MakeCycleWhere(bn *binance.Binance, actionType int) {
	var list goex.MockResults
	log.Printf("数据回测 - 数据整理中....")
	if actionType == WhereAll {
		list = m.MakeCycleWhereAll(bn)
	} else {
		list = m.MakeCycleWhereSplit(bn)
	}
	var f *excelize.File
	log.Printf("[%vm]回测完毕,数据: %v 组\n", m.Cycle, len(list))
	pl := list.SplitToFlotList("desc", true)
	for i := 0; i < len(pl); i++ {
		itemMock := pl[i]
		if itemMock.IsLiquidation {
			continue
		}

		//log.Printf("订单簿------------Start")
		//for i := 0; i < len(itemMock.Order); i++ {
		//	item := itemMock.Order[i]
		//	fmt.Printf("[%v]买入:%v [%v]卖出:%v 持仓:%v 爆仓价:%v 持仓量:%v 保证金:%v 净收益:%v [Rsi:%v Mfi:%v]\r\n",
		//		time.UnixMilli(item.BidTime).Format(helper.TimeFormatYmdHis),
		//		item.Open,
		//		time.UnixMilli(item.AskTime).Format(helper.TimeFormatYmdHis),
		//		item.Close,
		//		item.Quantity,
		//		item.Liquidation, item.Quantity, item.Bail, item.NetGainUSd,
		//		decimal.NewFromFloat(item.BuyRsi).Round(2),
		//		item.BuyMfi,
		//	)
		//}
		//log.Printf("订单簿------------End")
		itemMock.ExportOrders(m.Cycle, m.StartDay, m.EndDay)
		log.Printf("%v分钟[%s-%s]回测数据: 初始余额:%v 当前余额:%v 交易次数:%v  MFi:[len:%v-%v] Rsi:[len:%v-%v] Rvi[len:%v-%v] 收益率:%v 止损率:%v %%  爆仓:%v \n",
			m.Cycle, m.StartDay, m.EndDay, itemMock.OldUsd, itemMock.Usd, itemMock.TradeNum,
			itemMock.MfiLength, itemMock.MfiMin,
			itemMock.RsiLength, itemMock.RsiMin,
			itemMock.RviLength, itemMock.RviMin,
			itemMock.ProfitRate,
			itemMock.StopLossRate,
			helper.IfThen(itemMock.IsLiquidation, "是", "否"))
		break
	}

	f = xjexcel.ListToExcel(list, "", fmt.Sprintf("%vm回测数据", m.Cycle))
	helper.Exists("mocktest", true, true)
	err := f.SaveAs(fmt.Sprintf("mocktest/%vm回测数据.xlsx", m.Cycle))
	if err != nil {
		log.Fatal("保存失败")
		return
	}
}
func (m *MockCyCle) MakeCycleWhereAll(bn *binance.Binance) (list goex.MockResults) {
	var wg = new(sync.WaitGroup)
	m.Brackets = LoadBrackets(bn) //加载杠杆信息
	whereOne := m.RunCycleWhere()
	log.Printf("条件重组完成:共%v组数据", len(whereOne))
	pool := tunny.NewFunc(10000000, func(i interface{}) interface{} {
		_one := whereOne[i.(int)]
		var r = _one.RsiOrder(m)
		list = append(list, *r)
		log.Printf("正在执行第%v个任务 \n", i.(int))
		wg.Done()
		return nil
	})
	kline := binance.GetKLines("FUTURES_UM", "klines", "daily", m.StartDay, m.EndDay,
		[]string{fmt.Sprintf("%vm", m.Cycle)}, []string{m.Symbol.ToSymbol("")}, m.Symbol)
	log.Printf("K线数据读取完毕,共%v条 等待排序...", len(kline))
	m.kLineData = goex.KlineSort(kline, "asc")
	log.Println("K线数据排序完成")
	trades := binance.GetTrade("FUTURES_UM", "trades", "daily", m.StartDay, m.EndDay, []string{}, []string{m.Symbol.ToSymbol("")}, m.Symbol)
	log.Printf("交易数据读取完毕,共%v条 等待排序...", len(trades))
	m.TradeData = goex.BubbleSortGeneric1(trades, runtime.NumCPU())
	log.Printf("数据加载完毕，等待整合,[K线:%v-交易记录:%v]\n", len(m.kLineData), len(m.TradeData))

	m.KlineLinkTrade() //关联K线与交易记录
	log.Printf("[%v]日数据关联完成[%v]", time.UnixMilli(m.kLineData[0].CloseTime).Format(helper.TimeFormatYmdHis), len(m.KlinsLikeTrade))

	//defer func() {
	//	pool.Close()
	//	m.kLineData = nil
	//	m.TradeData = nil
	//	m.KlinsLikeTrade = nil
	//}()

	for iR := 0; iR < len(whereOne); iR++ {
		wg.Add(1)
		go pool.Process(iR)
	}
	log.Println("任务分发完成，正在执行...")
	wg.Wait()
	return list
}

// MakeCycleWhereSplit 分割回测 防止数据过大 造成溢出
func (m *MockCyCle) MakeCycleWhereSplit(bn *binance.Binance) (list goex.MockResults) {
	// 将K线数据 按天分割后 逐一回测
	var klinData = binance.DownloadData("FUTURES_UM", "klines", "daily", m.StartDay, m.EndDay, []string{fmt.Sprintf("%vm", m.Cycle)}, []string{m.Symbol.ToSymbol("")})
	var tradeData = binance.DownloadData("FUTURES_UM", "trades", "daily", m.StartDay, m.EndDay, []string{}, []string{m.Symbol.ToSymbol("")})
	log.Printf("数据加载完毕，等待整合,[%v-%v]\n", len(klinData), len(tradeData))
	m.Brackets = LoadBrackets(bn) //加载杠杆信息

	whereOne := m.RunCycleWhere()
	log.Printf("条件重组完成:共%v组数据", len(whereOne))
	var wg = new(sync.WaitGroup)
	for i := 0; i < len(klinData); i++ {
		m.kLineData = []*goex.Kline{}
		m.TradeData = []*goex.Trade{}
		// 按天分割后的K线数据与交易记录
		m.kLineData = goex.LocalKlineCsv(klinData[i], m.Symbol)
		m.TradeData = goex.LocalTradeCsv(tradeData[i], m.Symbol)
		m.KlineLinkTrade() //关联K线与交易记录
		log.Printf("[%v]日数据关联完成[%v]", time.UnixMilli(m.kLineData[0].CloseTime).Format(helper.TimeFormatYmdHis), len(m.KlinsLikeTrade))
		for iR := 0; iR < len(whereOne); iR++ {
			_iR := iR
			go func() {
				wg.Add(1)
				_one := whereOne[_iR]
				var r = _one.RsiOrder(m)
				wg.Done()
				if i >= len(klinData)-1 {
					list = append(list, *r)
				}
			}()
		}
		wg.Wait()
		log.Printf("处理完毕")
	}
	return list
}

// checkExchangeWhere 检测是否达到买入条件
func (m *WhereCycleOne) checkExchangeWhere() {

}

// RsiOrder Rsi量化大法
func (m *WhereCycleOne) RsiOrder(mockData *MockCyCle) (r *goex.MockResult) {
	_mockResult := &goex.MockResult{
		RsiLength:    m.RsiLength,
		RsiMin:       m.RsiMin,
		RsiMax:       m.RsiMax,
		MfiMin:       m.MfiMin,
		MfiMax:       m.MfiMax,
		MfiLength:    m.MfiLength,
		RviMin:       m.RviMin,
		RviMax:       m.RviMax,
		RviLength:    m.RviLength,
		ProfitRate:   m.ProfitRate,
		OldUsd:       m.MockDetail.OldUsd,
		StopLossRate: m.StopLossRate,
	}
	// 测试数据爆仓后 不再进行操作
	if m.IsLiquidation {
		return
	}
	for i := 0; i < len(mockData.kLineData); i++ {
		if i >= len(mockData.kLineData)-2 {
			_mockResult.Usd = m.MockDetail.Usd
			_mockResult.TradeNum = m.MockDetail.TradeNum
			_mockResult.Order = m.MockDetail.HistoryOrder
		}
		var item = mockData.kLineData[i]
		m.CalcKline(item, 0)
		signal := m.GetSignal()

		if signal == goex.OPEN_BUY && !m.MockDetail.OrderStatus { //达到买多条件 - 判断有无货币购买(包含资金切割) 注意:非本地回测下，数据具有实时性
			m.MockDetail.Mutex.Lock()
			var order = &goex.MockOrder{
				Direction: m.MockDetail.Direction,
				Type:      m.MockDetail.Type,
				Lever:     m.MockDetail.Lever,
				Quantity:  helper.IfThen(m.MockDetail.Type == goex.NewOrder_UM, m.MockDetail.Usd*5, m.MockDetail.Usd),
				FeeRate:   m.MockDetail.FeeRate,
				CpUsd:     m.MockDetail.CpUsd,
			}
			order.BidTime = item.CloseTime
			order.BuyRsi = m.LastRsi
			order.BuyMfi = m.LastMfi
			order.BuyRvi = m.LastRvi
			order.Buy(item.Close)                                                             //非本地数据回测下 数据具有实时性
			order.CalcLiquidation(m.MockDetail.Usd, mockData.Brackets[m.Symbol.ToSymbol("")]) //计算爆仓价 传参格式 余额 保证金维持比例
			m.MockDetail.Order = order
			m.MockDetail.TradeNum++
			m.MockDetail.OrderStatus = true
			m.MockDetail.Mutex.Unlock()
			//因为本地数据回测  是根据K线收盘价操作  所以下买单后  需要在下一个K线判断是否卖出/平多
			continue
		}
		if m.MockDetail.OrderStatus {
			//如果持有订单的情况下 需要取出当前K线中的所有交易 逐一进行比对 达到收益率后 进行平仓/卖出操作
			var trade = mockData.KlinsLikeTrade[item.CloseTime]
			for ir := 0; ir < len(trade); ir++ {
				var itemTrade = trade[ir]
				order := m.MockDetail.Order
				if helper.IfThen(order.Type == goex.NewOrder_Buy, itemTrade.Price <= order.Liquidation, itemTrade.Price >= order.Liquidation) { //爆仓啦
					_mockResult.IsLiquidation = true
					m.IsLiquidation = true
					_mockResult.Usd = m.MockDetail.Usd
					_mockResult.TradeNum = m.MockDetail.TradeNum
					m.MockDetail.Order.Sell(itemTrade.Price)
					m.MockDetail.Order.AskTime = itemTrade.Date
					m.MockDetail.Order.CalcCpUp()
					m.MockDetail.HistoryOrder = append(m.MockDetail.HistoryOrder, m.MockDetail.Order)
					_mockResult.Order = m.MockDetail.HistoryOrder
					return _mockResult
				}
				spot := &goex.MockOrder{
					Direction: order.Direction,
					Type:      order.Type,
					Lever:     order.Lever,
					Quantity:  order.Quantity,
					FeeRate:   order.FeeRate,
					CpUsd:     order.CpUsd,
				}
				spot.Buy(order.Open)
				spot.Sell(itemTrade.Price)
				spot.CalcCpUp()
				if spot.NetRate >= m.ProfitRate || spot.NetRate <= m.StopLossRate { //如果收益率达标 或者亏损率达标 进行平仓/卖出操作
					m.MockDetail.OrderStatus = false
					m.MockDetail.Order.Sell(itemTrade.Price)
					m.MockDetail.Order.AskTime = itemTrade.Date
					m.MockDetail.Order.CalcCpUp()
					m.MockDetail.Usd += spot.NetGainUSd
					m.MockDetail.Order.Usd = m.MockDetail.Usd
					m.MockDetail.HistoryOrder = append(m.MockDetail.HistoryOrder, m.MockDetail.Order)
					break
				}
			}
		}
	}

	return _mockResult
}

// LoadBrackets 加载币种杠杆与保证金信息
func LoadBrackets(bn *binance.Binance) Brackets {
	brk := make(Brackets)
	lp := bn.Brackets()
	for i := range lp {
		item := lp[i]
		brk[item.Symbol] = &item
	}
	log.Printf("杠杆与保证金列表加载完毕:%v", len(brk))
	return brk
}

// CalcTrade 通过传入交易记录 进行后置处理
func CalcTrade(trade *goex.Trade) {

}

// CalcKline 通过K线 进行数据后置处理
func (m *WhereCycleOne) CalcKline(kline *goex.Kline, i int) {
	if len(m.kLineData) <= 0 {
		m.kLineData = append(m.kLineData, kline)
	} else if kline.Timestamp == m.kLineData[len(m.kLineData)-1].Timestamp {
		m.kLineData[len(m.kLineData)-1] = kline
	} else {
		m.kLineData = append(m.kLineData, kline)
	}
	if len(m.kLineData) > 167 {
		m.kLineData = m.kLineData[1:]
	}
}
func (m *WhereCycleOne) GetSignal() int {
	//return m.SignalRsi()
	var s1, s2, s3 = m.SignalMfi(), m.SignalRsi(), m.SignalRvi()
	if s1 == s2 || s1 == s3 || s2 == s3 && (s1 != -1 || s2 != -1) {
		m.Signal = s1
	}
	return m.Signal
}

// SignalMfi Mfi信号
func (m *WhereCycleOne) SignalMfi() int {
	mfi := goex.CalcMfi(m.kLineData, m.MfiLength)
	if len(mfi) == 0 && len(m.kLineData) < m.MfiLength+1 {
		return -1
	}
	m.LastMfi = mfi[len(mfi)-1]
	if m.LastMfi >= m.MfiMin && m.MfiMin != 0 {
		return goex.OPEN_BUY //买入 / 平空信号
	}
	if m.LastMfi >= m.MfiMax && m.MfiMax != 0 {
		return goex.OPEN_SELL //卖出 / 平多信号
	}
	return -1 // -1为未识别信号
}

// SignalRsi Rsi信号
func (m *WhereCycleOne) SignalRsi() int {
	rsi := goex.CalcRsi(m.kLineData, m.RsiLength)
	if len(rsi) == 0 && len(m.kLineData) < m.RsiLength+1 {
		return -1
	}
	m.LastRsi = rsi[len(rsi)-1]
	if m.LastRsi >= m.RsiMin && m.RsiMin != 0 {
		return goex.OPEN_BUY //买入 / 平空信号
	}
	if m.LastRsi >= m.RsiMax && m.RsiMax != 0 {
		return goex.OPEN_SELL //卖出 / 平多信号
	}
	return -1 // -1为未识别信号
}

// SignalRvi Rvi信号
func (m *WhereCycleOne) SignalRvi() int {
	rvi := goex.CalcRvgi(m.kLineData, m.RviLength)
	if len(rvi) == 0 {
		return -1
	}
	m.LastRvi = rvi[len(rvi)-1]
	if m.LastRvi >= m.RviMin {
		return goex.OPEN_BUY //买入 / 平空信号
	}
	if m.LastRvi >= m.RviMax && m.RviMax != 0 {
		return goex.OPEN_SELL //卖出 / 平多信号
	}
	return -1 // -1为未识别信号
}

// SubTrade 订阅交易记录
func (m *WhereCycleOne) SubTrade(bn *binance.BinanceWs) {
	err := bn.SubscribeAggTrade(m.Symbol, func(trade *goex.Trade) {
		CalcTrade(trade)
	})
	if err != nil {
		fmt.Println("运行失败", err)
	}
}

// SubKline 读取并订阅K线
func (m *WhereCycleOne) SubKline(bn *binance.BinanceWs, bnt *binance.BinanceSwap) {
	var err error
	m.kLineData, err = bnt.GetKlineRecords(m.Symbol, goex.KLINE_PERIOD_5MIN, 167, 0)
	if err != nil {
		log.Fatalf("运行失败,获取K线报错-%v", err.Error())
	}
	m.RsiArr = goex.CalcRsi(m.kLineData, m.RsiLength)
	m.MfiArr = goex.CalcMfi(m.kLineData, m.MfiLength)
	bn.KlineCallback = m.CalcKline
	err = bn.SubscribeKline(m.Symbol, goex.KLINE_PERIOD_5MIN)
	if err != nil {
		fmt.Println("运行失败", err)
	}
}

// 读取在线K线数据
func onLineKline(bn *binance.BinanceWs, bnt *binance.BinanceSwap) {
	mc := WhereCycleOne{
		Comm:      Comm{Symbol: goex.BNB_USDT},
		RsiLength: 14,
		MfiLength: 6,
	}
	mc.SubKline(bn, bnt)
}
